<!DOCTYPE html>
<html lang="en">

<head>
	<title>Castle</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../three.js/examples/main.css">
</head>

<body>

	<script type="module">

		import * as THREE from '../three.js/build/three.module.js';
		import {FBXLoader} from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/FBXLoader.js';
		import {GLTFLoader} from 'https://cdn.jsdelivr.net/npm/three@0.118.1/examples/jsm/loaders/GLTFLoader.js';
		import { OrbitControls } from '../three.js/examples/jsm/controls/OrbitControls.js';
		import { CameraControls } from '../three.js/examples/jsm/controls/experimental/CameraControls.js';

		let camera, scene, renderer;
		let plane, road, door, gate, castleWindow;
		let pointer, raycaster;
		let cubeGeo, cubeMaterial;
		const loader = new GLTFLoader();

		const TextureLoader = new THREE.TextureLoader();

		const grass = TextureLoader.load('textures/grass.jpg');
		const brick = TextureLoader.load('../three.js/examples/textures/brick_bump.jpg');
		const redbrick = TextureLoader.load('textures/Roof_Tiles_Terracotta_006_basecolor.jpg');
		const sky = TextureLoader.load('textures/sky.jpg');
		const paving = TextureLoader.load('textures/floor.jpg');
		const woodenDoor = TextureLoader.load('textures/door.png');
		const guardGateTexture = TextureLoader.load('textures/gate.png');
		const windowTexture = TextureLoader.load('textures/window.png');
		const ac = 	loader.load('./resources/ac/skeletonzombie_t_avelange.fbx');
		render(ac);
		
	
		
    

		const tiles = new THREE.MeshLambertMaterial({ map: redbrick });
		const material = new THREE.MeshLambertMaterial({ map: brick });
		const guardGate = new THREE.MeshLambertMaterial({ map: guardGateTexture, transparent: true });

		const objects = [];

		let x, y, z;

		init();
		render();
		


		function init() {
			camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 10000);
			camera.position.set(500, 800, 1300);
			camera.lookAt(0, 0, 0);

			scene = new THREE.Scene();
			scene.background = sky;

			//south wall
			x = -500;
			y = 25;
			z = 525;
			createWall(x, y, z, "south", 21, 3);

			//north wall
			x = -500;
			y = 25;
			z = -575;
			createWall(x, y, z, "north", 21, 3);

			//west wall
			x = -475;
			y = 25;
			z = -525;
			createWall(x, y, z, "west", 21, 3);

			//east wall
			x = 525;
			y = 25;
			z = -525;
			createWall(x, y, z, "east", 21, 3);

			//south west tower
			x = -400;
			y = 50 * 5 / 2;
			z = 450;
			createTower(x, y, z);

			//south east tower
			x = 450;
			y = 50 * 5 / 2;
			z = 450;
			createTower(x, y, z);

			//north east tower
			x = 450;
			y = 50 * 5 / 2;
			z = -500;
			createTower(x, y, z);

			//north west tower
			x = -400;
			y = 50 * 5 / 2;
			z = -500;
			createTower(x, y, z);

			//central piece
			x = -250;
			y = 25;
			z = -250;
			createWall(x, y, z, "north", 11, 6);

			x = -250;
			y = 25;
			z = 250;
			createWall(x, y, z, "south", 3, 6);
			x = 150;
			y = 25;
			z = 250;
			createWall(x, y, z, "south", 3, 6);

			x = -275;
			y = 25;
			z = -250;
			createWall(x, y, z, "west", 11, 6);

			x = 325;
			y = 25;
			z = -250;
			createWall(x, y, z, "east", 11, 6);

			//central tower
			x = -125;
			y = 25;
			z = -150;
			createWall(x, y, z, "north", 6, 11, "no");

			x = 180;
			y = 25;
			z = -125;
			createWall(x, y, z, "east", 6, 11, "no");

			x = -125;
			y = 25;
			z = -125;
			createWall(x, y, z, "west", 6, 11, "no");

			x = -125;
			y = 25;
			z = 150;
			createWall(x, y, z, "south", 6, 11, "no");

			//central pyramidal roof
			x = 25;
			y = 625;
			z = 0;
			const pyramidRoofGeo = new THREE.CylinderGeometry(1, 50 * 6, 50 * 4, 4);
			const pyramidRoof = new THREE.Mesh(pyramidRoofGeo, tiles);
			pyramidRoof.rotateY(-Math.PI / 4);
			pyramidRoof.position.set(25, 625, 0);
			scene.add(pyramidRoof);



			raycaster = new THREE.Raycaster();
			pointer = new THREE.Vector2();

			const grassGeo = new THREE.PlaneGeometry(300, 300);
			grassGeo.rotateX(-Math.PI / 2);
			x = -600;
			y = 0;
			z = -600;

			// const gridHelper = new THREE.GridHelper(1500, 25);
			// gridHelper.position.set(0, 0, 0);
			// scene.add(gridHelper);

			for (var i = 0; i < 5; i++) {
				for (var j = 0; j < 5; j++) {
					plane = new THREE.Mesh(grassGeo, new THREE.MeshLambertMaterial({ map: grass }));
					plane.position.set(x, y, z);
					if (j % 2 == 0) {
						plane.rotateY(Math.PI / 2);
					}
					if (i % 2 != 0) {
						plane.rotateY(Math.PI / 2);
					}
					if (i % 2 != 0 && j % 2 != 0) {
						plane.rotateY(Math.PI);
					}

					scene.add(plane);
					x = x + 300;
				}

				x = -600;
				z = z + 300;
			}
			objects.push(plane);



			const roadGeo = new THREE.PlaneGeometry(250, 300);
			roadGeo.rotateX(-Math.PI / 2);
			x = 25;
			y = 1;
			z = 600;

			for (var i = 0; i < 2; i++) {
				road = new THREE.Mesh(roadGeo, new THREE.MeshLambertMaterial({ map: paving }));
				road.position.set(x, y, z);
				scene.add(road);
				z = z - 300;
			}

			const doorGeo = new THREE.PlaneGeometry(200, 200);
			x = 25;
			y = 100;
			z = 176;
			door = new THREE.Mesh(doorGeo, new THREE.MeshLambertMaterial({ map: woodenDoor }));
			door.position.set(x, y, z);
			scene.add(door);

			// const gateGeo = new THREE.BoxGeometry(300, 300, 50);
			// const gateFrame = [
			// 	material,
			// 	material,
			// 	material,
			// 	material,
			// 	guardGate,
			// 	guardGate
			// ]
			// gate = new THREE.Mesh(gateGeo, gateFrame);
			// gate.position.set(x, y + 50, z + 350);
			// scene.add(gate);


			createWindow(x, y + 300, z, 200, 200, "south");
			createWindow(x, y + 300, z - 352, 200, 200, "north");
			createWindow(x + 181, y + 300, z - 172, 200, 200, "east");
			createWindow(x - 176, y + 300, z - 172, 200, 200, "west");

			// lights
			const ambientLight = new THREE.AmbientLight(0x606060);
			scene.add(ambientLight);

			const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
			directionalLight.position.set(1, 0.75, 0.5).normalize();
			scene.add(directionalLight);

			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);

			document.body.appendChild(renderer.domElement);
			document.addEventListener('pointermove', onPointerMove);

			window.addEventListener('resize', onWindowResize);
		}

		function createWindow(x, y, z, height, width, direction) {
			const windowGeo = new THREE.PlaneGeometry(height, width);
			castleWindow = new THREE.Mesh(windowGeo, new THREE.MeshLambertMaterial({ map: windowTexture, transparent: true }));
			console.log(direction);
			switch (direction) {
				case 'south':
					castleWindow.position.set(x, y, z);
					scene.add(castleWindow);
					break;

				case 'north':
					castleWindow.position.set(x, y, z);
					castleWindow.rotateY(-Math.PI);
					scene.add(castleWindow);
					break;

				case 'east':
					castleWindow.position.set(x, y, z);
					castleWindow.rotateY(Math.PI / 2);
					scene.add(castleWindow);
					break;

				case 'west':
					castleWindow.position.set(x, y, z);
					castleWindow.rotateY(-Math.PI / 2);
					scene.add(castleWindow);
					break;

				default:
					console.log("wrond window direction value");
			}

		}
			function Model() {
			loader.load('./resources/thing.glb', (gltf) => {
			gltf.scene.traverse(c => {
				c.castShadow = true;
			});
			scene.add(gltf.scene);
			render(gltf.scene);
			}); }

		function createWall(x, y, z, side, length, height, noIndent) {
			console.log(noIndent);
			let indent;
			let xstart = x;
			let zstart = z;
			switch (side) {
				case 'north':
					for (var i = 0; i < height; i++) {
						for (var j = 0; j < length; j++) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							const cube = new THREE.Mesh(wall, material);
							cube.position.set(x + 25, y, z);
							x = x + 50;
							scene.add(cube);
						}
						x = xstart;
						y = y + 50;
					}
					if (noIndent === undefined) {
						indent = 1;
						for (var j = 0; j < length; j++) {
							if (indent % 2 != 0) {
								const wall = new THREE.BoxGeometry(50, 50, 50);
								const cube = new THREE.Mesh(wall, material);
								cube.position.set(x + 25, y, z);
								x = x + 50;
								scene.add(cube);
								indent += 1;
							} else {
								indent += 1;
								x = x + 50
								continue;
							}
						}
					} else {
						console.log("no indent");
					}
					break;

				case 'west':
					for (var i = 0; i < height; i++) {
						for (var j = 0; j < length; j++) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							const cube = new THREE.Mesh(wall, material);
							cube.position.set(x, y, z);
							z = z + 50;
							scene.add(cube);
						}
						z = zstart;
						y = y + 50;
					}
					if (noIndent === undefined) {
						indent = 1;
						for (var j = 0; j < length; j++) {
							if (indent % 2 == 0) {
								const wall = new THREE.BoxGeometry(50, 50, 50);
								const cube = new THREE.Mesh(wall, material);
								cube.position.set(x, y, z);
								z = z + 50;
								scene.add(cube);
								indent += 1;
							} else {
								indent += 1;
								z = z + 50
								continue;
							}
						}
					} else {
						console.log("no indent");
					}
					break;

				case 'east':
					for (var i = 0; i < height; i++) {
						for (var j = 0; j < length; j++) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							const cube = new THREE.Mesh(wall, material);
							cube.position.set(x, y, z)
							z = z + 50
							scene.add(cube);
						}
						z = zstart
						y = y + 50
					}
					if (noIndent === undefined) {
						indent = 0;
						for (var j = 0; j < length; j++) {
							if (indent % 2 != 0) {
								const wall = new THREE.BoxGeometry(50, 50, 50);
								const cube = new THREE.Mesh(wall, material);
								cube.position.set(x, y, z);
								z = z + 50;
								scene.add(cube);
								indent += 1;
							} else {
								indent += 1;
								z = z + 50
								continue;
							}
						}
					} else {
						console.log("no indent");
					}
					break;

				case 'south':
					for (var i = 0; i < height; i++) {
						for (var j = 0; j < length; j++) {
							const wall = new THREE.BoxGeometry(50, 50, 50);
							if (j > 6 && j < 14) {
								if (j == 7 || j == 13) {
									const cube = new THREE.Mesh(wall, material);
									cube.position.set(x + 25, y, z)
									scene.add(cube);
								}
							} else {
								const cube = new THREE.Mesh(wall, material);
								cube.position.set(x + 25, y, z)
								scene.add(cube);
							}
							x = x + 50;
						}
						x = xstart;
						y = y + 50;
					}
					if (noIndent === undefined) {
						indent = 1;
						for (var j = 0; j < length; j++) {
							if (indent % 2 != 0) {
								if (j != 8 && j != 10 && j != 12) {
									const wall = new THREE.BoxGeometry(50, 50, 50);
									const cube = new THREE.Mesh(wall, material);
									cube.position.set(x + 25, y, z);
									x = x + 50;
									scene.add(cube);
									indent += 1;
								} else {
									x = x + 50;
									indent += 1;
								}
							} else {
								indent += 1;
								x = x + 50
								continue;
							}
						}
					} else {
						console.log("no indent");
					}
					break;

				default:
					console.log("side not recognized")
			}
		}

		function createTower(x, y, z) {
			const tower = new THREE.CylinderGeometry(50, 50, 50 * 5, 320);
			const cylinder = new THREE.Mesh(tower, material);
			cylinder.position.set(x, y, z);
			scene.add(cylinder);
			y = y + 225
			const cone = new THREE.ConeGeometry(80, 200, 320);
			const roof = new THREE.Mesh(cone, tiles);
			roof.position.set(x, y, z);
			scene.add(roof);
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

			render();

		}
				function	LoadAnimatedModel() {
				const loader = new FBXLoader();
				loader.setPath('./resources/ac/');
				loader.load('skeletonzombie_t_avelange.fbx', (fbx) => {
				fbx.scale.setScalar(0.1);
				fbx.traverse(c => {
					c.castShadow = true;
				});

				const params = {
					target: fbx,
					camera: this._camera,
				}
				this._controls = new BasicCharacterControls(params);

				const anim = new FBXLoader();
				anim.setPath('./resources/ac/');
				anim.load('walk.fbx', (anim) => {
					const m = new THREE.AnimationMixer(fbx);
					this._mixers.push(m);
					const idle = m.clipAction(anim.animations[0]);
					idle.play();
				});
				render();
				});
			}

		function onPointerMove(event) {
			pointer.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
			raycaster.setFromCamera(pointer, camera);
			render();
		}

		function render() {
			renderer.render(scene, camera);
		}



		const controls = new OrbitControls(camera, renderer.domElement);
		controls.target.set(0, 12, 0);
		controls.update();

  

	</script>

</body>

</html>